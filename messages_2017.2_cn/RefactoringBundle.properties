readonly.occurences.found=\u5728\u53ea\u8bfb\u6587\u4ef6\u4e2d\u627e\u5230\u5339\u914d\u9879
progress.text=\u67e5\u770b\u7528\u6cd5
usageView.tabText=\u91cd\u6784\u9884\u89c8
usageView.usagesText=\u7528\u6cd5
usageView.need.reRun=Cannot perform refactoring operation.\nThere were changes in code after usages have been found.\nPlease perform usage search again.
usageView.doAction=\u8fdb\u884c\u91cd\u6784
statusBar.refactoring.result={0, choice, 1#1 occurrence|2#{0,number} occurrences} \u4fee\u6539\u8fc7
statusBar.noUsages=\u6ca1\u6709\u53d1\u73b0
anonymousToInner.refactoring.name=Convert Anonymous to Inner
anonymousToInner.no.inner.class.name=Class name should be specified
inner.class.exists=\u540d\u4e3a''{0}''\u7684\u5185\u90e8\u7c7b\u5df2\u7ecf\u5b9a\u4e49\n\u5728\u7c7b''{1}''\u4e2d
anonymousToInner.class.name.label.text=\u7c7b\u540d:
anonymousToInner.make.class.static.checkbox.text=Make class &static
anonymousToInner.parameters.panel.border.title=\u6784\u9020\u51fd\u6570\u53c2\u6570
error.wrong.caret.position.method=Caret should be positioned inside method to be refactored
error.wrong.caret.position.constructor=Caret should be positioned inside constructor to be refactored
error.wrong.caret.position.method.or.class.name=Caret should be positioned at the name of method or class to be refactored
error.wrong.caret.position.method.or.variable.name=Caret should be positioned at the name of method or variable to be refactored
error.wrong.caret.position.anonymous=Caret should be positioned inside anonymous class to be refactored
error.wrong.caret.position.class=Caret should be positioned inside class to be refactored
error.wrong.caret.position.method.or.local.name=Caret should be positioned at the name of element to be refactored
error.wrong.caret.position.local.name=Caret should be positioned at the name of local variable to be refactored
error.wrong.caret.position.local.or.expression.name=Caret should be positioned at the name of local variable or expression to be refactored
error.wrong.caret.position.symbol.to.rename=Caret should be positioned at symbol to be renamed
error.wrong.caret.position.symbol.to.refactor=Caret should be positioned at symbol to be refactored
error.out.of.project.element=Selected {0} is not located inside the project
error.out.of.project.element.default=Selected element is not located inside the project
error.in.injected.lang.prefix.suffix=Selected {0} is located in the read-only part of injected language document
error.cannot.be.renamed=\u4e0d\u80fd\u91cd\u547d\u540d\u8fd9\u4e2a\u5143\u7d20
to.refactor=\u53bb\u91cd\u6784
error.cannot.resolve=Cannot resolve {0}
error.incorrect.data=\u4e0d\u6b63\u786e\u7684\u6570\u636e
error.wrong.name.input=\u9519\u8bef\u7684\u540d\u79f0: {0}
error.not.supported.for.jsp={0} refactoring is not supported for JSP
error.not.supported.for.package.info={0} refactoring is not supported for package-info.java
changeClassSignature.refactoring.name=\u6539\u53d8\u7c7b\u7b7e\u540d
changeClassSignature.no.type.parameters=\u7c7b\u4e0d\u80fd\u6709\u7c7b\u578b\u53c2\u6570
changeClassSignature.parameters.panel.border.title=\u53c2\u6570
changeClassSignature.bad.value=Wrong {0} value: ''{1}'' for parameter ''{2}''
changeClassSignature.class.label.text=\u66f4\u6539 {0} \u7684\u7b7e\u540d
changeSignature.no.type.for.parameter=\u6307\u5b9a\u53c2\u6570 ''{1}'' \u7684\u7c7b\u578b\u4e3a {0}
changeSignature.no.type.for.exception=\u6307\u5b9a\u5f02\u5e38\u7684\u7c7b\u578b
changeSignature.refactoring.name=\u66f4\u6539\u7b7e\u540d
column.name.name=\u540d\u5b57:
changeSignature.default.value.column=\u9ed8\u8ba4\u503c:
changeSignature.bound.value.column=\u7ed1\u5b9a\u503c:
parameters.border.title=\u53c2\u6570
changeSignature.exceptions.panel.border.title=\u5f02\u5e38
changeSignature.propagate.parameters.title=Propa&gate Parameters...
changeSignature.propagate.exceptions.title=Propagate E&xceptions...
changeSignature.parameter.caller.chooser=Select Methods To Propagate New Parameters
changeSignature.exception.caller.chooser=Select Methods To Propagate New Exceptions
changeSignature.return.type.prompt=\u8fd4\u56de\u7c7b\u578b:
changeSignature.name.prompt=\u540d\u79f0:
name.prompt=\u540d\u79f0
signature.preview.border.title=\u7b7e\u540d\u9884\u89c8
changeSignature.parameters.wont.propagate=Recursive propagation of parameter changes won't be performed
changeSignature.exceptions.wont.propagate=Recursive propagation of exception changes won't be performed
changeSignature.wrong.return.type=\u9519\u8bef\u7684\u8fd4\u56de\u7c7b\u578b\uff1a''{0}''
changeSignature.no.return.type=\u672a\u6307\u5b9a\u8fd4\u56de\u7c7b\u578b
changeSignature.cannot.resolve.return.type=Return type ''{0}'' cannot be resolved.\nContinue?
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter ''{1}''
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.vararg.not.last=Vararg parameter should be the last in method signature
changeSignature.no.default.value=New parameter ''{0}'' has been added.\nSpecify a default value to be used in all existing calls of this method.
changeSignature.not.throwable.type=Wrong type ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.cannot.resolve.parameter.type=Type ''{0}'' for parameter ''{1}'' cannot be resolved.\nContinue?
search.in.comments.and.strings=\u5728\u6ce8\u91ca\u548c\u5b57\u7b26\u4e32\u4e2d\u641c\u7d22
search.for.text.occurrences=\u641c\u7d22\u6587\u672c\u5339\u914d\u9879
visibility.as.is=&As is
visibility.escalate=&Escalate
visibility.public=\u516c\u7528
visibility.protected=\u53d7\u4fdd\u62a4(&O)
visibility.private=\u79c1\u6709
visibility.package.local=Pac&kage local
visibility.border.title=Visibility
default.visibility.border.title=\u9ed8\u8ba4\u7684\u53ef\u89c1\u6027
visibility.combo.title=&Visibility:
moveInstanceMethod.select.an.instance.parameter=Select an &instance expression:
destination.package=\u76ee\u6807\u6587\u4ef6\u5305:
choose.destination.package=\u9009\u62e9\u76ee\u6807\u6587\u4ef6\u5305
interface.name.prompt=\u63a5\u53e3\u540d\u79f0:
package.for.new.interface=&Package for new interface:
turnRefsToSuper.change.usages.to=&Change usages of {0} to:
turnRefsToSuper.use.superclass.in.instanceof=&Use interface/superclass in instanceof
class.name.prompt=\u7c7b\u540d\u79f0:
parameter.name.prompt=\u53c2\u6570\u540d\u79f0:
no.class.name.specified=\u6ca1\u6709\u6307\u5b9a\u7c7b\u540d
no.parameter.name.specified=\u6ca1\u6709\u6307\u5b9a\u53c2\u6570\u540d\u79f0
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
pull.up.members.to=P&ull up members of {0} to:
members.to.be.pulled.up=Mem&bers to be pulled up
make.abstract=Make abstract
javadoc.for.abstracts=JavaDoc for abstracts
extractIncludeFile.name=\u63d0\u53d6\u5305\u542b\u6587\u4ef6
file.already.exist=\u6587\u4ef6 {0} \u5df2\u7ecf\u5b58\u5728
file.already.exist.title=\u63d0\u53d6\u5305\u542b\u6587\u4ef6
name.for.extracted.include.file=&Name for extracted include file (default extension: {0})
extract.to.directory=\u63d0\u53d6\u5230\u76ee\u5f55:
select.target.directory=\u9009\u62e9\u76ee\u6807\u76ee\u5f55
select.target.directory.description=\u5c06\u6b64\u76ee\u5f55\u4e2d\u521b\u5efa\u6587\u4ef6
create.directory=\u521b\u5efa\u76ee\u5f55
replace.inheritance.from=&Replace with delegation inheritance from:
field.name=\u5b57\u6bb5\u540d\u79f0(&F)\uff1a
inner.class.name=\u5185\u90e8\u7c7b\u540d\u79f0(&I)\uff1a
superclass.name=&Super class name:
delegate.members=Delegate mem&bers
generate.getter.for.delegated.component=Generate &getter for delegated component
package.for.new.superclass=&Package for new superclass:
package.for.original.class=&Package for original class:
package.for.original.interface=&Package for original interface:
ExtractSuperClass.superclass=\u8d85\u7c7b
members.to.form.superclass=Mem&bers to form superclass
no.superclass.name.specified=\u672a\u6307\u5b9a\u8d85\u7c7b\u540d\u79f0
extract.superclass.from=\u4ece\u4e2d\u63d0\u53d6\u8d85\u7c7b\uff1a
extractSuper.extract=\u63d0\u53d6 {0}
extractSuper.rename.original.class=R&ename original class and use {0} where possible
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.interface=\u63a5\u53e3
members.to.form.interface=Mem&bers to form interface
extract.interface.from=Extract interface from:
rename.implementation.class.to=Rename implementation class to:
rename.original.interface.to=Rename original interface to:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=\u672a\u6307\u5b9a\u63a5\u53e3\u540d\u79f0
replace.all.occurences=\u66ff\u6362\u6240\u6709\u7684\u5339\u914d\u9879({0}\u5339\u914d\u9879)
declare.final=final\u58f0\u660e
introduce.parameter.title=\u63d0\u53d6\u53c2\u6570
parameter.of.type=\u53c2\u6570\u7684\u7c7b\u578b:
use.variable.initializer.to.initialize.parameter=Use variable &initializer to initialize parameter
replace.fields.used.in.expressions.with.their.getters=Replace fields used in expressions with their getters
do.not.replace=\u4e0d\u8981\u66ff\u6362(&N)
replace.fields.inaccessible.in.usage.context=Replace fields &inaccessible in usage context
replace.all.fields=\u66ff\u6362\u6240\u6709\u5b57\u6bb5(&R)
class.does.not.exist.in.the.project=Class does not exist in project. Do you want to create it?
no.field.name.specified=\u672a\u6307\u5b9a\u5b57\u6bb5\u540d\u79f0
field.exists=Field with name {0}\nalready exists in class ''{1}''.\nContinue?
choose.destination.class=Choose Destination Class
replace.write.access.occurrences=Rep&lace write access occurrences

# introduce variable
introduce.variable.title=\u5f15\u5165\u7c7b\uff08\u5168\u4fee\u9970\u540d\uff09\uff1a
refactoring.introduce.context.error=Cannot perform refactoring in this context
refactoring.introduceVariable=Extract Variable refactoring
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)
refactoring.introduce.name.error=\u4e0d\u6b63\u786e\u7684\u540d\u79f0
refactoring.introduce.name.used.error=\u8fd9\u4e2a\u540d\u5b57\u5df2\u88ab\u4f7f\u7528
refactoring.introduce.variable.scope.error=\u4e0e\u73b0\u6709\u7684\u53d8\u91cf\u540d\u79f0\u51b2\u7a81
refactoring.introduce.placing.error=Cannot extract {0} variable

variable.of.type=Variable of &type:
convert.to.instance.method.title=Convert To Instance Method
convertToInstanceMethod.method.is.not.static=\u4e0d\u80fd\u6267\u884c\u91cd\u6784\n\u65b9\u6cd5 {0} \u975e\u9759\u6001\u3002
convertToInstanceMethod.no.parameters.with.reference.type=There are no parameters that have reference type
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=No target class for the instance method is found: all referenced types are unknown
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No target class for the instance method is found: all referenced types are not in project
cannot.perform.refactoring=\u4e0d\u80fd\u6267\u884c\u91cd\u6784\u3002
move.instance.method.title=Move Instance Method
move.method.is.not.supported.for.constructors=Move method is not supported for constructors
move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp class is referenced in method
there.are.no.variables.that.have.reference.type=There are no variables that have reference type
all.candidate.variables.have.unknown.types=All candidate variables have unknown types
all.candidate.variables.have.types.not.in.project=All candidate variables have types that are not in project
use.interface.where.possible.title=Use Interface Where Possible
interface.does.not.have.base.interfaces=Interface {0} does not have base interfaces
the.field.should.be.declared.in.a.class=\u5e94\u5728\u7c7b\u4e2d\u58f0\u660e\u8be5\u5b57\u6bb5\u3002
encapsulate.fields.title=Encapsulate Fields
fields.to.be.refactored.should.belong.to.the.same.class=Fields to be refactored should belong to the same class
encapsulate.fields.refactoring.cannot.be.applied.to.interface=Encapsulate fields refactoring cannot be applied to interface
extract.interface.title=\u63d0\u53d6\u63a5\u53e3
extract.interface.command.name=\u63d0\u53d6\u63a5\u53e3 {0} from {1}
extract.method.title=\u63d0\u53d6\u65b9\u6cd5
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor
selected.block.should.represent.a.set.of.statements.or.an.expression=Selected block should represent a set of statements or an expression
press.escape.to.remove.the.highlighting=Press Escape to remove the highlighting
extract.superclass.title=\u63d0\u53d6\u8d85\u7c7b
extract.superclass.command.name=\u63d0\u53d6\u8d85\u7c7b {0} from {1}
superclass.cannot.be.extracted.from.an.interface=\u4e0d\u80fd\u4ece\u4e00\u4e2a\u63a5\u53e3\u4e2d\u63d0\u53d6\u8d85\u7c7b\u3002
superclass.cannot.be.extracted.from.an.enum=\u4e0d\u80fd\u4ece\u4e00\u4e2a\u679a\u4e3e\u4e2d\u63d0\u53d6\u8d85\u7c7b\u3002
replace.inheritance.with.delegation.title=Replace Inheritance With Delegation
class.is.interface={0} is an interface.
class.does.not.have.base.classes.or.interfaces=\u7c7b{0}\u6ca1\u6709\u57fa\u7c7b\u6216\u63a5\u53e3\u3002
inline.title=\u5185\u8054
introduce.constant.title=\u63d0\u53d6\u5e38\u91cf
introduce.selection.error=Cannot perform refactoring using selected element(s)
selected.expression.cannot.be.a.constant.initializer=Selected expression cannot be a constant initializer
variable.does.not.have.an.initializer=\u53d8\u91cf{0}\u6ca1\u6709\u521d\u59cb\u5316\u3002
initializer.for.variable.cannot.be.a.constant.initializer=Initializer for variable {0} cannot be a constant initializer
cannot.introduce.field.in.interface=Cannot extract field in the interface
introduce.field.title=\u5f15\u5165\u5e38\u91cf
selected.block.should.represent.an.expression=Selected block should represent an expression
is.not.supported.in.the.current.context={0} is not supported in current context
type.of.the.selected.expression.cannot.be.determined=Type of selected expression cannot be determined.
selected.expression.has.void.type=Selected expression has void type.
to.rename=to rename
to.delete.with.usage.search=to delete (with usage search)
unknown.expression.type=\u672a\u77e5\u7684\u8868\u8fbe\u5f0f\u7c7b\u578b\u3002
invalid.expression.context=Invalid expression context.
refactoring.is.not.supported.in.the.current.context={0} refactoring is not supported in the current context
cannot.introduce.variable.in.super.constructor.call=Cannot extract variable in super constructor call
is.modified.in.loop.body={0} is modified in loop body
introducing.variable.may.break.code.logic=Introducing variable may break code logic
no.selection=No selection.
selection.does.not.form.a.fragment.for.extraction=Selection does not form a fragment for extraction
cannot.extract.selected.elements.into.include.file=Cannot extract selected elements into include file
the.language.for.selected.elements.has.no.associated.file.type=The language for selected elements has no associated file type
extract.include.file.title=\u63d0\u53d6\u5305\u542b\u6587\u4ef6
replace.fragment=Replace Fragment
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} has found fragments that can be replaced with include directive\nDo you want to review them?
remove.duplicates.command=\u5220\u9664\u590d\u5236\u7684\u5185\u5bb9
make.method.static.title=Make Method Static
constructor.cannot.be.made.static=\u6784\u9020\u51fd\u6570\u4e0d\u80fd\u662f\u9759\u6001\u7684\u3002
this.member.does.not.seem.to.belong.to.any.class=\u6b64\u6210\u5458\u4f3c\u4e4e\u4e0d\u5c5e\u4e8e\u4efb\u4f55\u7c7b\u3002
member.is.already.static=\u6210\u5458\u5df2\u7ecf\u662f\u9759\u6001\u7684\u3002
cannot.make.abstract.method.static=Cannot make abstract method static
inner.classes.cannot.have.static.members=\u5185\u90e8\u7c7b\u4e0d\u80fd\u6709\u9759\u6001\u6210\u5458\u3002
pull.members.up.title=Pull Members Up
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=Caret should be positioned inside a class to pull members from
class.does.not.have.base.classes.interfaces.in.current.project={0} does not have base classes/interfaces in current project
pullUp.command=Pulling members up from {0}
push.members.down.title=Push Members Down
the.caret.should.be.positioned.inside.a.class.to.push.members.from=Caret should be positioned inside a class to push members from
move.title=\u79fb\u52a8
ask.to.move.related.file=<html>Related file found: <code>{0}</code>.<br/>Move it as well?</html>
ask.to.move.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Move them as well?</html>
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=Caret should be positioned at the class, method or field to be refactored
select.refactoring.title=\u9009\u62e9\u91cd\u6784
what.would.you.like.to.do=\u4f60\u60f3\u505a\u4ec0\u4e48\uff1f
move.packages.to.another.package=Move {0} &packages to another package
move.package.to.another.package=Move &package ''{0}'' to another package
move.directories.to.another.source.root=Move {0} directories to &another source root
move.directory.to.another.source.root=Move directory {0} to &another source root
move.inner.class.to.upper.level=Move &inner class {0} to upper level
move.inner.class.to.another.class=\u79fb\u52a8\u5185\u90e8\u7c7b{0}\u5230\u53e6\u4e00\u4e2a\u7c7b(&M)
move.nonstatic.class.from.jsp.not.supported = Moving non-static classes from JSP page is not supported
package.occurs.in.package.prefixes.of.the.following.source.folders.n=Package {0} occurs in package prefixes of the following source folders:\n
these.package.prefixes.will.be.changed=These package prefixes will be changed.
rename.title=\u91cd\u547d\u540d
rename.not.supported=\u64cd\u4f5c\u4e0d\u88ab\u652f\u6301
related.file=\u76f8\u5173\u6587\u4ef6
rename.related.file.dialog.description=\u5c06\u76f8\u5173\u6587\u4ef6\u91cd\u547d\u540d\u4e3a:
multiple.directories.correspond.to.package=Multiple directories correspond to package\n
directories.and.all.references.to.package.will.be.renamed=\n\n\u662f\u5426\u53ea\u91cd\u547d\u540d\u6574\u4e2a\u5305\u6216\u76ee\u5f55\n{0}\uff1f
rename.package.button.text=\u91cd\u547d\u540d\u5305
rename.directory.button.text=\u91cd\u547d\u540d\u76ee\u5f55
rename.directories= \u91cd\u547d\u540d\u5168\u90e8
rename.current.directory= \u91cd\u547d\u540d\u5f53\u524d\u7684
move.current.directory= \u79fb\u52a8\u5f53\u524d\u7684
move.directories= \u79fb\u52a8\u5168\u90e8
warning.title=\u8b66\u544a
replace.constructor.with.factory.method.title=\u7528\u5de5\u5382\u65b9\u6cd5\u66ff\u4ee3\u6784\u9020\u51fd\u6570
class.does.not.have.implicit.default.constructor=Class {0} does not have implicit default constructor
would.you.like.to.replace.default.constructor.of.0.with.factory.method=Would you like to replace default constructor of {0} with factory method?
refactoring.is.not.supported.for.local.and.jsp.classes=Refactoring is not supported for local and JSP classes
refactoring.is.not.supported.for.jsp.classes=Refactoring is not supported for JSP classes
class.is.abstract={0} \u662f\u62bd\u8c61\u7684\u3002
method.is.not.a.constructor=\u65b9\u6cd5\u4e0d\u662f\u4e00\u4e2a\u6784\u9020\u51fd\u6570
safe.delete.title=\u5b89\u5168\u5220\u9664
replace.temp.with.query.title=Replace Temp with Query
cannot.replace.temp.with.query.in.interface=Cannot replace temp with query in interface
variable.has.no.initializer=\u53d8\u91cf{0}\u6ca1\u6709\u521d\u59cb\u5316\u3002
variable.has.no.dominating.definition=Cannot find a single definition to inline.
variable.is.never.used=\u53d8\u91cf {0} \u4ece\u672a\u4f7f\u7528
variable.is.accessed.for.writing=Variable ''{0}'' is accessed for writing.
variable.is.accessed.for.writing.and.used.with.inlined=Another variable ''{0}'' definition is used together with inlined one.
only.fields.variables.of.methods.of.valid.type.can.be.considered=Only fields, variables, method parameters\u00a0or methods of valid type can be considered.
unable.to.start.type.migration=Unable to start type migration
replace.method.code.duplicates.title=Replace Code Duplicates
locate.caret.inside.a.method=Locate caret inside a member.
replace.with.method.call.does.not.work.for.constructors=Replace With Method Call does not work for constructors
method.does.not.have.a.body=Method {0} does not have a body.
method.has.an.empty.body=Method {0} has an empty body.
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} has not found any duplicates
method.duplicates.found.message={0, choice, 1#1 code fragment|2#{0,number} code fragments} found
0.with.1.visibility.is.not.accessible.from.2={0} with {1} visibility won''t be accessible from {2}
0.contains.call.with.null.argument.for.parameter.1={0} contains call with null argument for parameter {1}
no.members.selected=No members selected
0.already.exists.in.the.target.class={0}\u5df2\u7ecf\u5b58\u5728\u5728\u76ee\u6807\u7c7b\u4e2d\u3002
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} is {1} and will not be accessible from {2}.
renamed.class.will.hide.0.in.1=Renamed class will hide {0} in {1}
there.is.already.a.0.it.will.conflict.with.the.renamed.1=There is already a {0}. It will conflict with the renamed {1}
0.will.override.renamed.1={0} will override renamed {1}
0.will.hide.renamed.1={0} will hide renamed {1}
local.will.be.hidden.renamed=renamed field will hide {0}
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=There is already a {0} in the {1}. It will conflict with the renamed parameter.
do.you.want.to.process.overriding.methods.with.covariant.return.type=Do you want to process overriding methods\nwith covariant return type?
changing.signature.of.0=Changing signature of {0}
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=There is already a {0} in {1}. It will conflict with the new parameter.
0.to.change.signature={0} to change signature
New.name.of.method.is.not.java.identifier=New name of method is not Java identifier
references.to.be.changed=References to be changed {0}
source.folder.0.has.package.prefix.1=Source folder {0} has package prefix ''{1}''\nPackage ''{2}'' cannot be created there.
javadoc.as.is=&As is
javadoc.copy=\u590d\u5236(&C)
javadoc.move=\u79fb\u52a8(&M)
replace.instance.qualifiers.with.class.references=Replace instance qualifiers with class references
make.0.static=Make {0} Static
0.already.has.parameter.named.1.use.this.name.anyway={0}\u5df2\u7ecf\u6709\u540d\u4e3a''{1}''\u7684\u53c2\u6570\u3002\n\u4ecd\u7136\u4f7f\u7528\u8fd9\u4e2a\u540d\u79f0\uff1f
this.method=This method
add.object.as.a.parameter.with.name=Add &object as a parameter with name:
add.object.as.a.parameter.to.constructors.with.name=Add &object as a parameter to constructors with name:
add.parameters.for.fields=Add parameters for &fields:
add.parameters.for.fields.to.constructors=Add parameters for &fields to constructors:
0.already.contains.field.1={0}\u5df2\u5305\u542b\u5b57\u6bb5{1}.
0.is.already.overridden.in.1={0} is already overridden in {1}. Method will not be pushed down to that class.
0.already.contains.inner.class.named.1={0}\u5df2\u5305\u542b\u540d\u4e3a{1}\u7684\u5185\u90e8\u7c7b\u3002
0.uses.1.which.is.pushed.down={0} uses {1}, which is pushed down
refactoring.cannot.be.performed=Refactoring cannot be performed
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=There is already a {0}. It will conflict with an introduced parameter
introduce.parameter.command=Introducing parameter to {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Parameter initializer contains {0}, but not all calls to method are in its class.
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} is not accessible from {1}. Value for introduced parameter in that method call will be incorrect.
use.interface.superclass.in.instanceof=Use interface/superclass in instanceof
introduce.parameter.to.method=\u5f15\u5165\u53c2\u6570\u5bf9\u8c61(_J)...
introduced.variable.will.conflict.with.0=\u5f15\u5165\u53d8\u91cf\u91cd\u6784
column.name.type=\u7c7b\u578b:
column.name.any.var=Any var
column.name.default.value=\u9ed8\u8ba4\u503c
caller.chooser.caller.method=\u8c03\u7528\u65b9\u6cd5
caller.chooser.callee.method=\u88ab\u8c03\u7528\u65b9\u6cd5
caller.chooser.looking.for.callers=\u5bfb\u627e\u8c03\u7528...
copy.class.clone.0.1=\u514b\u9686 {0} {1}
copy.class.copy.0.1=\u590d\u5236 {0} {1}
invalid.target.package.name.specified=\u6307\u5b9a\u7684\u76ee\u6807\u5305\u540d\u79f0\u65e0\u6548
invalid.target.package.name.default.package=\u4e0d\u80fd\u5c06\u7c7b\u79fb\u52a8\u5230\u9ed8\u8ba4\u5305
error.title=\u9519\u8bef
cannot.create.directory=\u4e0d\u80fd\u521b\u5efa\u76ee\u5f55
no.target.directory.specified=\u672a\u6307\u5b9a\u76ee\u6807\u76ee\u5f55
copy.files.new.name.label=\u65b0\u540d\u5b57:
no.new.name.specified=\u6ca1\u6709\u6307\u5b9a\u65b0\u540d\u5b57
copy.files.copy.specified.files.label=\u590d\u5236\u6307\u5b9a\u6587\u4ef6
copy.files.copy.specified.directories.label=\u590d\u5236\u6307\u5b9a\u76ee\u5f55
copy.files.copy.specified.mixed.label=\u590d\u5236\u6307\u5b9a\u7684\u6587\u4ef6\u548c\u76ee\u5f55
copy.files.to.directory.label=\u5230\u76ee\u5f55:
the.file.will.be.copied.to.this.directory=\u6587\u4ef6\u5c06\u88ab\u590d\u5236\u5230\u8fd9\u4e2a\u76ee\u5f55\u4e2d
copy.files.clone.title=\u514b\u9686
copy.files.copy.title=\u590d\u5236
copy.files.clone.file.0=\u514b\u9686\u6587\u4ef6 {0}
copy.files.copy.file.0=\u590d\u5236\u6587\u4ef6 {0}
copy.files.clone.directory.0=\u514b\u9686\u76ee\u5f55 {0}
copy.files.copy.directory.0=\u590d\u5236\u76ee\u5f55 {0}
copy.handler.copy.class=\u590d\u5236\u7c7b
copy.handler.clone.class=\u514b\u9686\u7c7b
copy,handler.clone.files.directories=\u514b\u9686\u6587\u4ef6\u6216\u76ee\u5f55
copy.handler.copy.files.directories=\u590d\u5236\u6587\u4ef6\u6216\u76ee\u5f55
encapsulate.fields.get.access.checkbox=\u83b7\u53d6\u6743\u9650(&G)
encapsulate.fields.set.access.checkbox=\u8bbe\u7f6e\u6743\u9650(&S)
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=&Use accessors even when field is accessible
encapsulate.fields.private.radio=\u79c1\u6709(&I)
encapsulate.fields.protected.radio=\u53d7\u4fdd\u62a4
encapsulate.fields..package.local.radio=Package lo&cal
encapsulate.fields.encapsulate.border.title=Encapsulate
encapsulate.fields.options.border.title=\u9009\u9879
encapsulate.fields..encapsulated.fields.visibility.border.title=Encapsulated Fields' Visibility
encapsulate.fields.accessors.visibility.border.title=Accessors' Visibility
encapsulate.fields.fields.to.encapsulate.border.title=Fields to Encapsulate
encapsulate.fields.field.column.name=\u5b57\u6bb5(&F)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.no.fields.selected=\u6ca1\u6709\u9009\u62e9\u5b57\u6bb5
encapsulate.fields.command.name=Encapsulating fields in {0}
encapsulate.fields.getter.exists=There already is a method {0} which differs from getter {1} by return type only.
encapsulate.fields.setter.exists=There already is a method {0} which differs from setter {1} by return type only.
encapsulate.fields.fields.to.be.encapsulated=Fields to be encapsulated
invocations.to.be.inlined=Invocations to be inlined {0}
classes.to.push.down.members.to=Classes to push down members to {0}
references.in.code.to.elements.from.migration.map=References in code to elements from migration map "{0}" {1}
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\nto migrate using the migration map "{0}"\n
declaration.s.to.be.generified=Declaration(s) to be generified {0}
occurences.to.be.migrated=Occurrences to be migrated {0}
references.in.code=References in code {0}
safe.delete.comment.occurences.header=Occurrences found in comments, strings and non-code files {0}. Those occurrences will not be changed
move.single.element.elements.header={0} to be moved to {1}
references.in.code.to.0.1=References in code to {0} {1}
move.classes.elements.header=Classes to be moved to {0}
move.packages.elements.header=Packages to be moved to {0}
references.found.in.code=References found in code
references.found.in.generated.code=References found in generated code
comments.elements.header=Occurrences found in comments, strings and non-code files {0}
move.files.elements.header=Files to be moved to {0}
move.directories.elements.header=Directories to be moved to {0}
make.static.description.label=Make {0} {1} static
there.is.already.a.0.in.1=There is already a {0} in {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} uses non-static {1}, which is not passed as a parameter
0.uses.1.which.needs.class.instance={0} uses {1}, which needs class instance.
method.0.is.overridden.by.1=Method {0} is overridden by {1}.
make.static.command=Making {0} static
introduce.parameter.elements.header=Adding parameter to a method
annotate.field.as.nonnls.checkbox=Annotate &field as @NonNls
replace.all.occurences.checkbox=\u66ff\u6362\u6240\u6709\u7684\u5339\u914d\u9879(&a)
introduce.constant.introduce.to.class=\u5f15\u5165\u53c2\u6570\u5230\u65b9\u6cd5\uff1a
introduce.field.static.field.of.type=Static field of &type:
introduce.field.field.of.type=\u5b57\u6bb5\u7684\u7c7b\u578b:
replace.all.occurrences.of.expression.0.occurrences=\u66ff\u6362\u6240\u6709\u7684\u5339\u914d\u9879(&a)({0})
delete.variable.declaration=&Delete variable declaration
initialize.in.border.title=\u521d\u59cb\u5316\u4f4d\u7f6e
setup.method.radio=&setUp method
current.method.radio=\u5f53\u524d\u65b9\u6cd5(&C)
field.declaration.radio=\u5b57\u6bb5\u58f0\u660e(&R)
class.constructors.radio=\u7c7b\u6784\u9020\u51fd\u6570(&C)
convert.local.to.field.title=Convert Local to Field
introduce.constant.field.of.type=Constant (static final field) of &type:
extract.subclass.command=Extract Subclass
extract.superclass.elements.header=Extract superclass with members to directory
declare.static.checkbox=Declare &static
declare.generated.annotations=\u751f\u6210\u6ce8\u91ca(&G)
declare.static.pass.fields.checkbox=\u58f0\u660e &static (\u901a\u8fc7\u57df\u4f5c\u4e3a\u53c2\u6570)
introduce.functional.variable.pass.fields.checkbox=Pass &fields as params
declare.varargs.checkbox=Declare v&arargs
declare.folded.parameters=&Fold parameters
extract.method.method.panel.border=\u65b9\u5f0f
there.are.multiple.exit.points.in.the.selected.code.fragment=There are multiple exit points in the selected code fragment.
move.members.elements.header=Members to be moved
move.members.move.members.from.label=Move members from:
move.members.to.fully.qualified.name.label=To (fully qualified name):
move.members.members.to.be.moved.border.title=Mem&bers to be moved (static only)
no.destination.class.specified=\u672a\u6307\u5b9a\u76ee\u6807\u7c7b
0.is.not.a.legal.fq.name=''{0}'' is not a legal FQ-name
create.class.command=\u521b\u5efa\u7c7b{0}
source.and.destination.classes.should.be.different=Source and destination classes should be different
cannot.move.inner.class.0.into.itself=Cannot move inner class {0} into itself.
class.0.does.not.exist=\u7c7b{0}\u4e0d\u5b58\u5728\u3002\n\u60a8\u60f3\u521b\u5efa\u5b83\u5417\uff1f
move.members.title=\u79fb\u52a8\u6210\u5458
members.to.be.moved.should.belong.to.the.same.class=Members to be moved should belong to the same class.
field.0.is.not.static=Field {0} is not static.\n{1} refactoring is supported for static members only.
0.refactoring.cannot.be.applied.to.constructors={0} refactoring cannot be applied to constructors
method.0.is.not.static=Method {0} is not static.\n{1} refactoring is supported for static members only.
inner.class.0.is.not.static=\u5185\u90e8\u7c7b{0}\u975e\u9759\u6001\uff0c\n{1}\u91cd\u6784\u53ea\u652f\u6301\u9759\u6001\u6210\u5458\u3002
inline.field.title=Inline Field
0.refactoring.is.supported.only.for.final.fields={0} refactoring is supported only for final fields
no.initializer.present.for.the.field=No initializer present for the field
field.0.is.never.used=Field {0} is never used
inline.field.command=Inline field {0}
0.is.used.for.writing.in.1={0} is used for writing in {1}
0.will.not.be.accessible.from.1.after.inlining={0} will not be accessible from {1} after inlining
inline.field.field.name.label=\u5b57\u6bb5 {0} {1}
inline.field.border.title=\u5185\u8054
all.references.and.remove.the.field=\u5185\u8054\u6240\u6709\u5e76\u5220\u9664\u8be5\u5b57\u6bb5
all.references.keep.field=\u5185\u8054\u6240\u6709\u5e76\u4fdd\u6301\u5b57\u6bb5
all.references.and.remove.the.local=Inline &all references and remove the variable
this.reference.only.and.keep.the.variable=Inline this reference only and &keep the variable
this.reference.only.and.keep.the.field=Inline this only and &keep the field
all.references.and.remove.super.class=Inline &all references and remove the class
this.reference.only.and.keep.super.class=Inline this reference only and &keep the super class
inline.variable.title=Inline Variable
variable.is.referenced.in.multiple.files=Variable {0} is referenced in multiple files
variable.is.never.used.before.modification=\u4fee\u6539\u4e4b\u524d\u4ece\u672a\u4f7f\u7528\u53d8\u91cf {0}
inline.command=Inline {0}
inline.local.variable.prompt=Inline local variable ''{0}''?
inline.local.variable.definition.prompt=Inline local variable ''{0}'' definition?
occurences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
occurrences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
inline.method.title=\u5185\u8054\u65b9\u6cd5
inline.method.method.label=\u65b9\u6cd5 {0} {1}
inline.method.border.title=\u5185\u8054
all.invocations.and.remove.the.method=Inline &all and remove the method
all.invocations.keep.the.method=Inline all and k&eep the method
all.invocations.in.project=&All invocations in project
this.invocation.only.and.keep.the.method=Inline this only and &keep the method
refactoring.cannot.be.applied.to.abstract.methods={0} refactoring cannot be applied to abstract methods
refactoring.cannot.be.applied.no.sources.attached={0} refactoring cannot be applied: no sources attached
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0} refactoring is not supported when return statement interrupts the execution flow
refactoring.is.not.supported.for.recursive.methods={0} refactoring may not be applied to remove recursive methods.\nYou can inline only individual method calls.
refactoring.cannot.be.applied.to.vararg.constructors={0} refactoring cannot be applied to vararg constructors
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} refactoring cannot be applied to inline non-chaining constructors
inline.method.command=Inlining method {0}
inlined.method.implements.method.from.0=Inlined method implements method from {0}
inlined.method.overrides.method.from.0=Inlined method overrides method from {0}
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1={0} that is used in inlined method is not accessible from call site(s) in {1}
inline.method.elements.header=Method to inline
inline.field.elements.header=Field to inline
inline.class.elements.header=Class to inline
inline.vars.elements.header=Variable to inline
interface.has.been.successfully.created=\u5df2\u6210\u529f\u521b\u5efa\u63a5\u53e3 {0}\u3002
class.has.been.successfully.created=\u5df2\u6210\u529f\u521b\u5efa\u7c7b {0}\u3002
use.super.references.prompt=At this stage {0} can analyze usages of {1} \nand replace them with usages of {2} where possible.\nDo you want to proceed?
analyze.and.replace.usages=Analyze and Replace Usages
there.are.multiple.output.values.for.the.selected.code.fragment=There are multiple output values for the selected code fragment:
expression.result=expression result
boolean.method.result=boolean method result
instances.of.0.upcasted.to.1.were.found=Instances of {0} upcasted to {1} were found. If you continue, they will be shown in a separate Find tab.
0.uses.1.of.an.instance.of.a.2={0} uses {1} of an instance of a {2}.
0.upcasts.an.instance.of.1.to.2={0} upcasts an instance of {1} to {2}.
0.will.no.longer.override.1={0}\u5c06\u4e0d\u518d\u91cd\u5199{1}
replacing.inheritance.with.delegation=Replacing inheritance with delegation
instances.casted.to.java.lang.object=Instances casted to java.lang.Object
instances.upcasted.to.object=Instances upcasted to Object
instances.upcasted.to.java.lang.object.found=Instances upcasted to java.lang.Object found
replace.inheritance.with.delegation.command=Replacing inheritance with delegation in {0}
replace.inheritance.with.delegation.elements.header=\u4e0e\u4ee3\u8868\u56e2\u66ff\u6362\u7ee7\u627f
# Inline included file
inline.included.file.title=Inline included file
the.caret.should.be.positioned.on.the.included.file.to.inline=The caret should be positioned on the included file reference to inline

inline.the.contents.include.prompt=Inline the contents of ''{0}''?
remove.include.prompt=Included file is no longer used. Remove it?
delete.include.command=\u5220\u9664{0}
make.static.elements.header={0} to be made static
field.0.is.not.accessible=Field {0} is not accessible from {1}
fields.0.are.not.accessible=Fields {0} are not accessible from {1}
0.is.not.static.it.cannot.be.moved.to.the.interface={0}\u4e0d\u662f\u9759\u6001\u7684\u3002\u4e0d\u80fd\u5c06\u5b83\u79fb\u52a8\u5230\u8be5\u63a5\u53e3
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} is not initialized in declaration. Such fields are not allowed in interfaces.
0.already.contains.a.1={0}\u5df2\u5305\u542b{1}
0.uses.1.which.is.not.accessible.from.the.superclass={0} uses {1}, which is not accessible from the superclass
0.uses.1.which.is.not.moved.to.the.superclass={0} uses {1}, which is not moved to the superclass
push.members.from.0.down.label=Push members from {0} down
members.to.be.pushed.down.panel.title=Mem&bers to be pushed down
keep.abstract.column.header=Keep abstract
push.down.javadoc.panel.title=JavaDoc for abstracts
push.down.members.elements.header=Push down members from {0}
interface.0.does.not.have.inheritors=Interface {0} does not have inheritors.
functional.interface.broken=Functional expression demands functional interface to have exact one method
class.0.does.not.have.inheritors=Class {0} does not have inheritors.
push.down.will.delete.members=Pushing members down will result in them being deleted. Would you like to create a new subclass?
edit.migration.map.title=Edit Migration Map
migration.map.name.prompt=Map name:
migration.map.description.label=Map description:
migration.add.button=\u6dfb\u52a0...
migration.edit.button=\u7f16\u8f91...
migration.remove.button=\u5220\u9664
migration.move.up.button=\u4e0a\u79fb
migration.move.down.button=\u4e0b\u79fb
migration.type.column.header=\u7c7b\u578b
migration.old.name.column.header=\u65e7\u540d\u5b57
migration.new.name.column.header=\u65b0\u540d\u5b57
migration.package.with.subpackages=Package with subpackages
migration.package=\u5305
migration.class=\u7c7b
edit.migration.entry.title=\u7f16\u8f91 \u7c7b/\u5305 \u8fc1\u79fb\u8bf4\u660e
migration.entry.package=\u5305
migration.entry.class=\u7c7b
migration.entry.old.name=\u65e7\u540d\u5b57:
migration.entry.new.name=\u65b0\u540d\u5b57:
select.migration.map=Select migration map:
migration.new.button=\u65b0\u5efa...
migration.dialog.title=Package and Class Migration
migration.dialog.ok.button.text=\u8fd0\u884c
migration.map.set.migration.maps=Migration maps
migration.no.usages.found.in.the.project=No Usages Found in the Project
migration.title=\u8fc1\u79fb
move.classes.move.to.another.source.folder=Move to another source &folder
move.specified.classes=\u79fb\u52a8\u6307\u5b9a\u7684\u7c7b
move.specified.packages=\u79fb\u52a8\u6307\u5b9a\u7684\u5305
move.single.class.or.package.name.label=\u79fb\u52a8{0} {1}
please.enter.a.valid.target.package.name=Please enter a valid target package name
package.does.not.exist=\u5305{0}\u4e0d\u5b58\u5728\u3002\n\u4f60\u60f3\u521b\u5efa\u5b83\u5417\uff1f
move.package.refactoring.cannot.be.applied.to.default.package=Move Package refactoring cannot be applied to default package
move.class.refactoring.cannot.be.applied.to.anonymous.classes=Move Class refactoring cannot be applied to anonymous classes
moving.local.classes.is.not.supported=Moving local classes is not supported.
there.are.going.to.be.multiple.destination.files.with.the.same.name=There are going to be multiple destination files with the same name.
do.you.wish.to.continue=\u8981\u7ee7\u7eed\u5417\uff1f
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=All these directories will be moved, and all references to {0} \nwill be changed.
select.source.root.chooser.title=Select Source Root
moving.directories.command=Moving directories
0.uses.a.package.local.1={0} uses package-private {1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local class {0} will no longer be accessible from {1}
element.will.no.longer.be.accessible={0} will no longer be accessible from {1}
move.instance.method.command=Move Instance method
move.instance.method.elements.header=Move instance method
move.method.this.parameter.label=Select a name for ''{0}.this'' parameter
move.method.enter.a.valid.name.for.parameter=Please Enter a Valid name for Parameter
0.is.an.interface.that.has.no.implementing.classes={0} is an interface that has no implementing classes
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} is an interface. \nMethod implementation will be added to all directly implementing classes.\n Proceed?
move.inner.to.upper.level.title=Move Inner to Upper Level
move.inner.class.command=\u79fb\u52a8\u5185\u90e8\u7c7b{0}
0.will.become.inaccessible.from.1={0} will become inaccessible from {1}
move.specified.files=\u79fb\u52a8\u6307\u5b9a\u7684\u6587\u4ef6
move.specified.directories=\u79fb\u52a8\u6307\u5b9a\u7684\u76ee\u5f55
move.file.0=\u79fb\u52a8\u6587\u4ef6{0}
move.directory.0=\u79fb\u52a8\u76ee\u5f55{0}
move.files.to.directory.label=\u5230\u76ee\u5f55:
the.file.will.be.moved.to.this.directory=\u8be5\u6587\u4ef6\u5c06\u88ab\u79fb\u5230\u6b64\u76ee\u5f55
searching.for.variables=Searching for variables
searching.for.duplicates=\u5bfb\u627e\u91cd\u590d\u7684...
no.usages.can.be.replaced=No usages of {0} \ncan be replaced with usages of {1}
turn.refs.to.super.command=Replacing usages of {0} with {1}
references.to.0.to.be.replaced.with.references.to.1=References to ''{0}'' to be replaced with references to ''{1}''
factory.method.name.label=\u5de5\u5382\u65b9\u6cd5\u540d(&N)\uff1a
replace.constructor.with.factory.target.fq.name=In (fully qualified name):
class.0.not.found=\u7c7b{0}\u672a\u627e\u5230\u3002
class.0.is.not.accessible.from.target.1=Class {0} is not accessible from target {1}
target.0.is.not.accessible.from.1=Target {0} is not accessible from {1}
constructor.being.refactored.is.used.in.initializer.of.0=Constructor being refactored is used in initializer of {0}. Non-static factory of inner class{1} cannot be used in this context. Resulting code will not compile.
replace.constructor.0.with.a.factory.method=Replace constructor {0} with a factory method
replace.default.constructor.of.0.with.a.factory.method=Replace default constructor of {0} with a factory method
replace.constructor.with.factory.method=Replace constructor with factory method
replace.default.constructor.with.factory.method=Replace default constructor with factory method
occurrences.found.in.comments.strings.and.non.java.files=Occurrences found in comments, strings and non-code files
occurrences.found.in.comments.strings.non.java.files.and.generated.code=Occurrences found in comments, strings, non-code files and generated code
0.referenced.in.1.will.not.be.accessible.in.module.2={0}, referenced in {1}, will not be accessible in module {2}
0.referenced.in.1.will.not.be.accessible.from.module.2={0}, referenced in {1}, will not be accessible from module {2}
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0}, referenced in {1}, will not be accessible from the production sources of module {2}
choose.destination.directory=\u9009\u62e9\u76ee\u6807\u76ee\u5f55
directory.chooser.hide.non.existent.checkBox.text=&Hide non-existent
0.will.be.inaccessible.from.1={0} will be inaccessible from {1}
move.classes.command=Moving {0} to package {1}
safe.delete.command=Deleting {0}
select.all.button=\u5168\u9009(&A)
unselect.all.button=&Unselect all
automatic.renamer.enity.name.column={0} name
automatic.renamer.rename.to.column=\u91cd\u547d\u540d\u4e3a
rename.0.and.its.usages.to=Rename {0} and its usages to:
rename.variables=\u91cd\u547d\u540d\u53d8\u91cf(&V)
rename.inheritors=\u91cd\u547d\u540d\u7ee7\u627f\u8005(&i)
rename.tests=\u91cd\u547d\u540d tests(&e)
rename.parameters.hierarchy=Rename parameters in hier&archy
rename.overloads=\u91cd\u547d\u540d &overloads
rename.bound.forms=\u91cd\u547d\u540d bound &forms
inner.class.0.is.already.defined.in.class.1=\u5185\u90e8\u7c7b{0}\u5df2\u88ab\u5b9a\u4e49\u5728\u7c7b{1}\u4e2d\u3002\n\u65e0\u8bba\u5982\u4f55\u90fd\u7ee7\u7eed\uff1f
class.0.already.exists=\u7c7b{0}\u5df2\u5b58\u5728
renaming.something=Renaming something
renaming.0.1.to.2=\u5c06{0} {1}\u91cd\u547d\u540d\u4e3a{2}
renaming.command.name=Renaming {0}
0.to.be.renamed.to.1.2={0} to be renamed to {1}{2}
references.in.code.to.0=References in code to {0}
rename.variables.title=\u91cd\u547d\u540d\u53d8\u91cf
rename.variables.with.the.following.names.to=Rename variables with the following names to:
entity.name.variable=\u53d8\u91cf
rename.bound.forms.title=Rename Bound Forms
rename.forms.with.the.following.names.to=Rename forms with the following names to:
entity.name.form=Form
rename.inheritors.title=Rename Inheritors
rename.tests.title=Rename Tests
rename.inheritors.with.the.following.names.to=Rename inheritors with the following names to:
rename.tests.with.the.following.names.to=Rename tests with the following names to:
entity.name.inheritor=Inheritor
entity.name.test=\u6d4b\u8bd5
unused.overriding.methods.title=\u672a\u4f7f\u7528\u7684\u8986\u5199\u65b9\u6cd5
there.are.unused.methods.that.override.methods.you.delete=\u6709\u672a\u4f7f\u7528\u7684\u65b9\u6cd5,\u4f60\u53ef\u4ee5\u5220\u9664\u8986\u5199\u65b9\u6cd5
choose.the.ones.you.want.to.be.deleted=Choose the ones you want to be deleted
method.column=\u65b9\u6cd5
0.implements.1={0} implements {1}.
attempting.to.delete.targets.node.text=Attempting to delete
retry.command=\u91cd\u8bd5
rerun.safe.delete=\u91cd\u65b0\u8fd0\u884c\u5b89\u5168\u5220\u9664(&R)
delete.title=\u5220\u9664
items.to.be.deleted=Items to be deleted
usages.detected=Usages Detected
delete.anyway.button=\u65e0\u8bba\u5982\u4f55\u90fd\u5220\u9664(&D)
ignore.button=\u5ffd\u7565
ask.to.delete.related.file=<html>Related file found: <code>{0}</code>.<br/>Delete it as well?</html>
ask.to.delete.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Delete them as well?</html>
the.following.problems.were.found=\u53d1\u73b0\u4ee5\u4e0b\u95ee\u9898\uff1a
cancel.button=\u53d6\u6d88
view.usages=&View Usages
anonymous.class.text=\u533f\u540d\u7c7b
problems.detected.title=Problems Detected
continue.button=\u7ee7\u7eed
do.you.wish.to.ignore.them.and.continue=\u8981\u5ffd\u7565\u5b83\u4eec\u5e76\u7ee7\u7eed\u5417\uff1f
delegation.panel.method.calls.label=Method calls:
delegation.panel.modify.radio=\u4fee\u6539
delegation.panel.delegate.via.overloading.method=De&legate via overloading method
information.title=\u4fe1\u606f
ok.button=\u786e\u5b9a
do.not.show.this.message.in.the.future=\u4ee5\u540e\u4e0d\u518d\u663e\u793a\u6b64\u6d88\u606f(&D)
member.column=\u6210\u5458
refactor.button=\u91cd\u6784
preview.button=\u9884\u89c8
yes.button=\u662f(&Y)
no.button=\u5426
preview.usages.to.be.changed=&Preview usages to be changed
replace.this.code.fragment=Replace this code fragment?
replace.this.code.fragment.and.make.method.static= (Method will be made static)
replace.this.code.fragment.and.make.method.static.visible= (Method will be made static and {0})
replace.this.code.fragment.and.make.method.visible= (Method will be made {0})
replace.this.code.fragment.and.change.signature=\nMethod signature will be changed to \n{0}
process.duplicates.title=Process Duplicate {0} of {1}
process.methods.duplicates.title=Process Method {2} Duplicate ({0} of {1})
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} has detected {1} code {1,choice,1#fragment|2#fragments} in this file that can be replaced with a call to extracted method. Would you like to review and replace {1,choice,1#it|2#them}?
replace.button=\u66ff\u6362
method.duplicates.method.label=\u65b9\u6cd5{0}
usages.detected.title=Usages Detected
generify.title=Generify
interface.member.dependency.required.by.interfaces=required by {0,choice,1#interface|2#interfaces}
member.info.implements.0=\u5b9e\u73b0{0}
member.info.extends.0=extends {0}
used.by.0=used by {0}
uses.0=uses {0}
field.description=\u5b57\u6bb5{0}
constructor.description=\u6784\u9020\u51fd\u6570 {0}
method.description=\u65b9\u6cd5{0}
parameter.description=parameter {0}
local.variable.description=\u5c40\u90e8\u53d8\u91cf {0}
package.description=package {0}
class.description=\u7c7b{0}
static.initializer.description=static initializer of class {0}
instance.initializer.description=instance initializer of class {0}
file.description=\u6587\u4ef6 {0}
directory.description=\u76ee\u5f55 {0}
0.is.located.in.a.jar.file={0} is located in a read-only container.
0.is.read.only={0} is read-only.
0.is.not.a.legal.java.identifier=''{0}'' is not a legal java identifier
method.0.is.already.defined.in.the.1=Method {0} is already defined in the {1}
method.0.will.hide.method.of.the.base.class=Method {0} will hide \nthe method of the base class {1}
method.0.will.implement.method.of.the.base.class=Method {0} will implement \na method of the base class {1}
method.0.will.override.a.method.of.the.base.class=Method {0} will override \na method of the base class {1}
current.class=current class
field.0.is.already.defined.in.the.1=Field {0} is already defined in the {1}
field.0.will.hide.field.1.of.the.base.class=Field {0} will hide \na field {1} of the base {2}
directory.0.already.contains.1.named.2=Directory {0} \nalready contains {1} named ''{2}''
directory.0.already.contains.a.file.named.1=Directory {0} \nalready contains a file named ''{1}''
getter.and.setter.methods.found.for.the.field.0=Getter and setter methods found for the field {0}. \n{1} them as well?
getter.method.found.for.the.field.0=Getter method found for the field {0}. \n{1} the getter as well?
setter.method.found.for.the.field.0=Setter method found for the field {0}. \n{1} the setter as well?
0.has.1.usages.that.are.not.safe.to.delete={0} has {1,choice,1#1 usage that is|2#{1,number} usages that are} not safe to delete.
safe.delete.of.those.0.in.comments.strings.non.code=Of those {0,choice,1#1 usage is|2#{0,number} usages are} in strings, comments, non-code files or generated code.
safe.delete.conflict.title=Potentially unsafe to delete references found in code
type.cook.drop.obsolete.casts=&Drop obsolete casts
type.cook.preserve.raw.arrays=Preserve raw &arrays
type.cook.leave.object.parameterized.types.raw=&Leave Object-parameterized types raw
type.cook.perform.exhaustive.search=Perform &exhaustive search
type.cook.generify.objects=Generify &Objects
type.cook.produce.wildcard.types=Produce &wildcard types
type.cook.command=Generify
type.cook.elements.header=Scope(s) to generify
type.cook.report=Items generified: {0}, casts removed: {1}
type.cook.ratio.generified={0,choice,-1#not calculated|0#{0,number} of {1}}
extract.method.control.flow.analysis.failed=Code contains syntax errors. Cannot perform necessary analysis.
pushed.members.will.not.be.visible.from.certain.call.sites=Pushed members will not be visible from certain call sites.
invert.boolean.title=Invert Boolean
invert.boolean.wrong.type=Return type of the method or type of the variable to be refactored should be boolean
invert.boolean.refs.to.invert=References to be inverted {0}
invert.boolean.elements.header={0} to invert
please.enter.a.valid.name.for.inverted.element=Please enter a valid name for inverted {0}
invert.boolean.name.of.inverted.element=&Name of inverted {0}:
invert.0.1=Invert {0} {1} and its usages
invert.boolean.foreach=Foreach parameter initializer can't be inverted
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}\u65b9\u6cd5\u662f\u5c42\u7ea7\u7684\u4e00\u90e8\u5206\u3002\u4f60\u60f3\u5220\u9664\u591a\u4e2a\u7c7b\u578b\u53c2\u6570\uff1f
move.inner.class.to.be.moved=Class to be moved
move.specified.classes.to=\u79fb\u52a8\u6307\u5b9a\u7684\u7c7b\u5230\uff1a
destination.directory.does.not.correspond.to.any.package=The destination directory does not correspond to any package
cannot.find.or.create.destination.directory=\u65e0\u6cd5\u627e\u5230\u6216\u521b\u5efa\u76ee\u6807\u76ee\u5f55
cannot.move=Cannot Move
cannot.move.package.into.itself=Cannot move package into itself
rename.constructor.parameters.title=Rename Constructor Parameters
rename.constructor.parameters.with.the.following.names.to=Rename parameters with the following names to:
entity.name.constructor.parameter=\u53c2\u6570
replace.method.duplicates.scope.chooser.title=\u6307\u5b9a\u8303\u56f4 {0}
replace.method.duplicates.scope.chooser.message=\u5206\u6790\u8303\u56f4
remove.parameter.0.no.longer.used=Remove parameter ''{0}'' no longer used
inline.to.anonymous.refactoring=Inline to Anonymous Class
inline.to.anonymous.no.abstract=\u62bd\u8c61\u7c7b\u4e0d\u80fd\u88ab\u5185\u8054
inline.to.anonymous.no.inheritors=Classes which have subclasses cannot be inlined
inline.to.anonymous.no.multiple.interfaces=Classes which implement multiple interfaces cannot be inlined
inline.to.anonymous.no.superclass.and.interface=\u6709\u8d85\u7c7b\u548c\u5b9e\u73b0\u4e86\u63a5\u53e3\u7684\u7c7b\u4e0d\u80fd\u88ab\u5185\u8054
move.class.to.inner.command.name=Move {0} to {1}
move.classes.destination.to.package=To packa&ge
move.classes.destination.make.inner=&Make inner class of
move.to.inner.duplicate.inner.class=\u7c7b{0}\u5df2\u5305\u542b\u4e00\u4e2a\u540d\u4e3a {1} \u7684\u5185\u90e8\u7c7b
inline.to.anonymous.command.name=Inline class {0}
class.is.never.used=\u7c7b\u4ece\u672a\u4f7f\u7528
all.references.and.remove.the.class=Inline &all references and remove the class
this.reference.only.and.keep.the.class=Inline &this reference only and &keep the class
inline.to.anonymous.name.label=\u7c7b{0}
inline.to.anonymous.border.title=\u5185\u8054
move.class.to.inner.nonstatic.error=It is not allowed to move a class into a non-static inner class
move.class.to.inner.move.to.self.error=It is not allowed to move a class into itself
unsupported.refs.found=Unsupported references found in {0} files
inline.method.checking.tail.calls.progress=Checking tail call usages
extract.chained.constructor.checkbox=\u63d0\u53d6\u94fe\u5f0f\u6784\u9020\u51fd\u6570
inline.parameter.refactoring=\u5185\u8054\u53c2\u6570
inline.parameter.confirmation=Inline parameter ''{0}'' with initializer ''{1}''?
inline.parameter.command.name=\u5185\u8054\u53c2\u6570 {0}
inline.parameter.error.hierarchy=Inline parameter is not supported when method is a part of inheritance hierarchy
inline.parameter.error.varargs=Inline for varargs parameters is not supported
inline.parameter.replace.with.local.checkbox=\u4f7f\u7528\u5c40\u90e8\u53d8\u91cf\u66ff\u6362
type.migration.rerun.button.text=\u91cd\u65b0\u8fd0\u884c\u7c7b\u578b\u8fc1\u79fb(&R)
type.migration.migrate.button.text=\u8fc1\u79fb(&M)
type.migration.exclude.action.text=\u6392\u9664(&E)
type.migration.include.action.text=\u5305\u62ec(&I)
introduce.constant.enum.cb=\u63d0\u53d6\u4e3a\u679a\u4e3e\u5e38\u91cf
move.enum.constant.cb=\u5982\u679c\u53ef\u80fd\u7684\u8bdd\u63d0\u53d6\u4e3a\u679a\u4e3e\u5e38\u91cf
move.to.different.language=Target class {2} has different language than {0} {1}
dont.support.inner.classes={0}\u4e0d\u652f\u6301\u5185\u90e8\u7c7b
move.specified.elements=\u79fb\u52a8\u6307\u5b9a\u7684\u5143\u7d20
rename.directory.title=\u91cd\u547d\u540d\u76ee\u5f55(&D)
rename.module.title=\u91cd\u547d\u540d\u6a21\u5757(&M)

# extract method
refactoring.extract.method.dialog.title=\u63d0\u53d6\u65b9\u6cd5
refactoring.extract.method.dialog.method.name=\u65b9\u5f0f\u540d\u79f0:
refactoring.extract.method.dialog.parameters=\u53c2\u6570
refactoring.extract.method.dialog.output.variables=\u8f93\u51fa\u53d8\u91cf
refactoring.extract.method.dialog.signature.preview=\u7b7e\u540d\u9884\u89c8
refactoring.extract.method.dialog.empty=\u7a7a
change.signature.leave.blank.default.value=\u4fdd\u7559\u7a7a\u767d
change.signature.feel.lucky=Feel &lucky
change.signature.use.selected.value=\u4f7f\u7528\u9009\u4e2d\u7684\u503c

search.for.references=\u5bfb\u627e\u5f15\u7528
0.is.not.an.identifier=<b><code>{0}</code></b> \u662f\u4e0d\u6b63\u786e\u7684\u6807\u8bc6\u7b26\uff0c\u5f53\u4f7f\u7528\u5728 <b><code>{1}</code></b>
refactoring.is.not.supported.for.language={0} \u4e0d\u652f\u6301 {1}
rename.directory.command.name=\u91cd\u547d\u540d\u76ee\u5f55
rename.directories.command.name=\u91cd\u547d\u540d\u76ee\u5f55
target.destination.folder=Target &destination directory:
move.method.is.not.supported.for.0=Move instance method is not supported for {0}
detecting.possible.conflicts=\u68c0\u6d4b\u53ef\u80fd\u7684\u51b2\u7a81...
path.completion.shortcut=Use {0} for path completion

rename.project.action.title=\u91cd\u547d\u540d\u9879\u76ee...
rename.project.handler.title=\u91cd\u547d\u540d\u9879\u76ee(&P)
enter.new.project.name=\u8f93\u5165\u65b0\u7684\u9879\u76ee\u540d:
rename.project=\u91cd\u547d\u540d\u9879\u76ee
renames.project=\u91cd\u547d\u540d\u9879\u76ee
introduce.functional.parameter.title=\u63d0\u53d6\u51fd\u6570\u53c2\u6570
introduce.functional.variable.title=Extract Functional Variable
introduce.parameter.convert.lambda=\u8f6c\u6362\u4e3a\u51fd\u6570\u8868\u8fbe\u5f0f

expand.method.reference.warning=Method is used in method reference. Proceeding would result in conversion to lambda expression
refactoring.introduce.parameter.object.references.to.be.modified=\u5f15\u7528\u88ab\u4fee\u6539
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=Method whose parameters are to wrapped
refactoring.introduce.parameter.object.command.name=Introduced parameter class {0} for {1}()
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=Method to extract parameters from
refactoring.introduce.parameter.object.title=Introduce Parameter Object

rename.module.already.exists=Module ''{0}'' already exists in the project